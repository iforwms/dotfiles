#!/usr/bin/env bash
# Usage: ./make_reel.sh <image_dir> <audio_file> [audio_start] [duration_per_image] [transition_duration]

IMG_DIR="$1"
AUDIO_FILE="$2"
AUDIO_START_TIME="${3:-0}"  # default = 0 (start of audio)
DURATION_PER_IMAGE="${4:-3}"
TRANSITION_DURATION="${5:-1}"

WORKDIR=$(mktemp -d)
trap 'rm -rf "$WORKDIR"' EXIT

# Collect images
shopt -s nullglob
IMAGES=("$IMG_DIR"/*.{jpg,jpeg,png,JPG,PNG})
IMAGE_COUNT=${#IMAGES[@]}
if [ $IMAGE_COUNT -eq 0 ]; then
  echo "No images found in $IMG_DIR"
  exit 1
fi

echo "ðŸ“¸ Images: $IMAGE_COUNT"
echo "ðŸ•’ Duration per image: $DURATION_PER_IMAGE s"
echo "ðŸŒˆ Transition duration: $TRANSITION_DURATION s"

# Resize images
i=1
for img in "${IMAGES[@]}"; do
  ffmpeg -y -i "$img" \
    -vf "scale=1920:1080:force_original_aspect_ratio=decrease,pad=1920:1080:(ow-iw)/2:(oh-ih)/2" \
    "$WORKDIR/$(printf "%04d.png" "$i")" >/dev/null 2>&1
  ((i++))
done

# Generate a list of inputs for filter_complex
INPUTS=()
for ((i=1;i<=IMAGE_COUNT;i++)); do
  INPUTS+=("-loop" "1" "-t" "$((DURATION_PER_IMAGE + TRANSITION_DURATION))" "-i" "$WORKDIR/$(printf "%04d.png" "$i")")
done

# Trim/pad audio to match total video length
TOTAL_VIDEO=$(echo "$IMAGE_COUNT * $DURATION_PER_IMAGE - ($DURATION_PER_IMAGE - $TRANSITION_DURATION)" | bc)
echo "TOTAL_VIDEO=${TOTAL_VIDEO}"
TRIMMED_AUDIO="$WORKDIR/audio_trimmed.mp3"
FADE_DURATION=2                 # seconds
FILTER="[0:a]atrim=start=$AUDIO_START_TIME:end=$(echo "$AUDIO_START_TIME + $TOTAL_VIDEO" | bc),asetpts=PTS-STARTPTS,
  afade=t=in:st=0:d=$FADE_DURATION,
  afade=t=out:st=$(echo "$TOTAL_VIDEO - $FADE_DURATION" | bc):d=$FADE_DURATION[a]"

echo "Audio filter: ${FILTER}"


ffmpeg -y -i "$AUDIO_FILE" -filter_complex "$FILTER" \
  -map "[a]" -ac 2 -c:a mp3 "$TRIMMED_AUDIO"

# Random transitions
TRANSITIONS=(fade wipeleft wiperight slideleft slideright circleopen circleclose rectcrop distance smoothleft fadeblack fadewhite)

# Build filter_complex string
FILTER=""
for ((i=0;i<IMAGE_COUNT;i++)); do
  FILTER+="[${i}:v]format=yuv420p,setsar=1[v$((i+1))];"
done

# Chain xfade transitions with correct cumulative offsets
CUM_OFFSET=0
for ((i=1;i<IMAGE_COUNT;i++)); do
  t="${TRANSITIONS[$RANDOM % ${#TRANSITIONS[@]}]}"
  if [ $i -eq 1 ]; then
    FILTER+="[v1][v2]xfade=transition=$t:duration=$TRANSITION_DURATION:offset=$DURATION_PER_IMAGE[vx$i];"
  else
    prev=$((i-1))
    FILTER+="[vx$prev][v$((i+1))]xfade=transition=$t:duration=$TRANSITION_DURATION:offset=$CUM_OFFSET[vx$i];"
  fi
  # Increment offset by duration per image (not including transition)
  CUM_OFFSET=$(echo "$CUM_OFFSET + $DURATION_PER_IMAGE" | bc)
  # CUM_OFFSET=$(echo "$CUM_OFFSET + $DURATION_PER_IMAGE - $TRANSITION_DURATION" | bc)
done

FINAL_OUT="[vx$((IMAGE_COUNT-1))]"

# Run ffmpeg
ffmpeg -y "${INPUTS[@]}" -i "$TRIMMED_AUDIO" \
  -filter_complex "$FILTER" \
  -map "$FINAL_OUT" -map "$IMAGE_COUNT:a" -shortest \
  -c:v libx264 -pix_fmt yuv420p output.mp4

echo "âœ… Done! output.mp4 created. Total duration ~ $TOTAL_VIDEO seconds"
