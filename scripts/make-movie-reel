#!/usr/bin/env bash
# Usage: ./make_reel.sh <image_dir> <audio_file> [audio_start] [duration_per_image] [transition_duration]

IMG_DIR="$1"
AUDIO_FILE="$2"
AUDIO_START_TIME="${3:-0}"  # default = 0 (start of audio)
DURATION_PER_IMAGE="${4:-3}"
TRANSITION_DURATION="${5:-1}"

WORKDIR=$(mktemp -d)
trap 'rm -rf "$WORKDIR"' EXIT

# Collect images
shopt -s nullglob
IMAGES=("$IMG_DIR"/*.{jpg,jpeg,png,JPG,PNG})
IMAGE_COUNT=${#IMAGES[@]}
if [ $IMAGE_COUNT -eq 0 ]; then
  echo "No images found in $IMG_DIR"
  exit 1
fi

IFS=',' read WIDTH HEIGHT < <(ffprobe -v error -select_streams v:0 \
    -show_entries stream=width,height -of csv=p=0:s=, "${IMAGES[0]}")

echo "ðŸ“ Using resolution ${WIDTH}x${HEIGHT}"

echo "ðŸ“¸ Found $IMAGE_COUNT images"
echo "ðŸ•’ Duration per image: $DURATION_PER_IMAGE s"
echo "ðŸŒˆ Transition duration: $TRANSITION_DURATION s"

# Resize to 1080p
i=1
for img in "${IMAGES[@]}"; do
  ffmpeg -y -i "$img" \
    -vf "scale=${WIDTH}:${HEIGHT}:force_original_aspect_ratio=decrease,pad=${WIDTH}:${HEIGHT}:(ow-iw)/2:(oh-ih)/2" \
    "$WORKDIR/$(printf "%04d.png" "$i")" >/dev/null 2>&1
  ((i++))
done

# Generate input list
INPUTS=()
for ((i=1;i<=IMAGE_COUNT;i++)); do
  INPUTS+=("-loop" "1" "-t" "$((DURATION_PER_IMAGE + TRANSITION_DURATION))" "-i" "$WORKDIR/$(printf "%04d.png" "$i")")
done

# Audio trimming and fading
FADE_DURATION=2
TOTAL_VIDEO=$(echo "$IMAGE_COUNT * $DURATION_PER_IMAGE - ($DURATION_PER_IMAGE - $TRANSITION_DURATION) + $FADE_DURATION" | bc)
TRIMMED_AUDIO="$WORKDIR/audio_trimmed.mp3"

ffmpeg -y -i "$AUDIO_FILE" \
  -filter_complex "[0:a]atrim=start=$AUDIO_START_TIME:end=$(echo "$AUDIO_START_TIME + $TOTAL_VIDEO" | bc),asetpts=PTS-STARTPTS,afade=t=in:st=0:d=$FADE_DURATION,afade=t=out:st=$(echo "$TOTAL_VIDEO - $FADE_DURATION" | bc):d=$FADE_DURATION[a]" \
  -map "[a]" -ac 2 -c:a mp3 "$TRIMMED_AUDIO"

# Define transition types
TRANSITIONS=(wipeleft wiperight wipeup wipedown smoothleft smoothright vertopen vertclose)

# Build filter graph
FPS=25
FILTER=""
for ((i=0;i<IMAGE_COUNT;i++)); do
  # Random zoom factor per image: 1.05 to 1.2 (5%-20%)
  ZOOM_FACTOR=$(awk -v min=1.05 -v max=1.2 'BEGIN{srand(); print min+rand()*(max-min)}')

  # Random zoom direction: 1 = zoom in, -1 = zoom out
  ZOOM_DIR=$((RANDOM % 2 * 2 - 1))  # either 1 or -1
  if [ "$ZOOM_DIR" -eq -1 ]; then
    START_ZOOM=$ZOOM_FACTOR
    END_ZOOM=1.0
  else
    START_ZOOM=1.0
    END_ZOOM=$ZOOM_FACTOR
  fi

  # Compute zoom increment per frame
  TOTAL_FRAMES=$(( (DURATION_PER_IMAGE + TRANSITION_DURATION) * FPS ))
  ZOOM_SPEED=$(awk -v sz=$START_ZOOM -v ez=$END_ZOOM -v tf=$TOTAL_FRAMES 'BEGIN{print (ez-sz)/tf}')

  # Random small pan offsets, fixed for the whole image (0-10% of width/height)
  X_OFF=$(awk -v min=-0.1 -v max=0.1 'BEGIN{srand(); print min+rand()*(max-min)}')
  Y_OFF=$(awk -v min=-0.1 -v max=0.1 'BEGIN{srand(); print min+rand()*(max-min)}')

  # Apply zoompan per image
  FILTER+="[${i}:v]format=yuv420p,setsar=1,zoompan="
  FILTER+="z='if(lte(zoom,${END_ZOOM}),zoom+${ZOOM_SPEED},zoom)':"
  FILTER+="x='iw/2-(iw/zoom/2)+iw*${X_OFF}':"
  FILTER+="y='ih/2-(ih/zoom/2)+ih*${Y_OFF}':"
  FILTER+="d=$TOTAL_FRAMES:s=${WIDTH}x${HEIGHT}[v$((i+1))];"
done

# Chain xfade transitions using the zoomed streams
FILTER+="[v1][v2]xfade=transition=${TRANSITIONS[$RANDOM % ${#TRANSITIONS[@]}]}:duration=$TRANSITION_DURATION:offset=$DURATION_PER_IMAGE[vx1];"
OFFSET=$DURATION_PER_IMAGE
for ((i=3;i<=IMAGE_COUNT;i++)); do
  OFFSET=$(echo "$OFFSET + $DURATION_PER_IMAGE" | bc)
  FILTER+="[vx$((i-2))][v$i]xfade=transition=${TRANSITIONS[$RANDOM % ${#TRANSITIONS[@]}]}:duration=$TRANSITION_DURATION:offset=$OFFSET[vx$((i-1))];"
done

# Add text overlay with line break + video fade in/out on the final output
VIDEO_FADE_IN=2
VIDEO_FADE_OUT=4
TEXT_END=15
TEXT_OVERLAY="Nynasvagen 84
Haninge"

FILTER+="[vx$((IMAGE_COUNT-1))]fade=t=in:st=0:d=$VIDEO_FADE_IN,\
fade=t=out:st=$(echo "$TOTAL_VIDEO - $VIDEO_FADE_OUT" | bc):d=$VIDEO_FADE_OUT,\
drawtext=fontfile=/System/Library/Fonts/Supplemental/AmericanTypewriter.ttc:text='$TEXT_OVERLAY':fontcolor=white:fontsize=48:box=1:boxcolor=black@0.5:boxborderw=10:x=(w-text_w)/2:y=(h-text_h)/2:enable='lte(t,$TEXT_END)',format=yuv420p[vout]"

# Run FFmpeg
CMD=(
  -y "${INPUTS[@]}" -i "$TRIMMED_AUDIO"
  -filter_complex "$FILTER"
  -map "[vout]" -map "$IMAGE_COUNT:a"
  -shortest -c:v libx264 -pix_fmt yuv420p output.mp4
)

echo "ðŸŽ¬ Running FFmpeg..."
ffmpeg "${CMD[@]}"

echo "âœ… Done! output.mp4 created (â‰ˆ ${TOTAL_VIDEO}s)"
